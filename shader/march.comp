#version 450
#extension GL_ARB_separate_shader_objects : enable



#define MAX_DIST	100
#define MIN_DIST	0.001
#define	MAX_STEP	50

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D result_image;

float	sphere_de(vec3 p)
{
	return (length(p) - 0.2);
}

float		mandelbulb_de(vec3 v)
{
	float	dr, r;
	vec3	w, z, z2, z4;
	vec3	vp = v;
	if (v == vec3(0.0, 0.0, 0.0))
		v.z = 0.02;

	//v.x = (vp.x * cos(time * 2.0) - vp.z * sin(time * 2.0));
	//v.z = (vp.x * sin(time * 2.0) + vp.z * cos(time * 2.0));
	dr = 1.0;
	w = v;
	r = w.x * w.x + w.y * w.y + w.z * w.z;
	for(int i = 0; i<30; i++)
	{
		dr = 8.0 * sqrt(r * r * r * r * r * r * r) * dr + 1.0;
		z = w;
		z2 = vec3(z.x * z.x, z.y * z.y, z.z * z.z);
		z4 = vec3(z2.x * z2.x, z2.y * z2.y, z2.z * z2.z);

		float k3 = z2.x + z2.z;
		float k2 = inversesqrt(k3*k3*k3*k3*k3*k3*k3);
		float k1 = z4.x + z4.y + z4.z - 6.0*z2.y*z2.z - 6.0*z2.x*z2.y + 2.0*z2.z*z2.x;
		float k4 = z2.x - z2.y + z2.z;

		w.x = v.x + 64.0 * z.x * z.y * z.z * (z2.x - z2.z) * k4 * (z4.x - 6.0 * z2.x * z2.z + z4.z) * k1 * k2;
		w.y = v.y + -16 * z2.y * k3 * k4 * k4 + k1 * k1;
		w.z = v.z + -8.0 * z.y * k4 * (z4.x * z4.x - 28.0 * z4.x * z2.x * z2.z + 70.0 * z4.x * z4.z - 28.0 * z2.x * z2.z * z4.z + z4.z * z4.z) * k1 * k2;

		//w.x += cos(time) * ((1684552.0 / 4) - (1684552.0 / 4)) * 3;
		//w.y += sin(time) * 1.7812 - cos(sqrt(time));
		//w.z -= 1.2 * cos(time) + sin(time) * 0.7;
		//w.x = (-sin(time) -cos(-time)) * w.x / 2.5;

		r = w.x * w.x + w.y * w.y + w.z * w.z;
		if (r > 256.0)
			return (0.25 * log(r) * sqrt(r) / dr);
	}
	return (0.25 * log(r) * sqrt(r) / dr);
}

float	marching(vec3 ro, vec3 rd)
{
	float	d = 0.;
	float	ds = 0.;
	vec3	p;

	for(int i = 0; i < MAX_STEP; i++)
	{
		p = ro + (rd * d);
		ds = mandelbulb_de(p);
		d += ds;
		if (d > MAX_DIST)
			return (MAX_STEP);
		if (ds <= MIN_DIST)
			return (i);
	}
	return (MAX_STEP);
}

vec3	coor_to_ray() 
{
	float	d_s;
	ivec2	dim = imageSize(result_image);
	vec3	r;
	vec2	uv = vec2(gl_GlobalInvocationID.xy) / dim - vec2(0.5, 0.5);
	vec2	coord = uv;

	d_s = 0.6;
	r.x = coord.x;
	r.y = coord.y;
	r.z = d_s;
	return (normalize(r));
}

void main()
{
	float	d;
	vec3	ro = vec3(0.0, 0.0, -3.0);
	float	iter;
	float	col;
	vec3	color;

	iter = marching(ro, coor_to_ray());
	col = (MAX_STEP - iter) / MAX_STEP;
	if (iter >= MAX_STEP)
		color = vec3(0.0, 0.0, 0.0);
	else
		color = vec3(col, col, col);
	imageStore(result_image, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}
